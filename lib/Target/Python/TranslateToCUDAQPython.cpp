/*******************************************************************************
 * Copyright (c) 2022 - 2023 NVIDIA Corporation & Affiliates.                  *
 * All rights reserved.                                                        *
 *                                                                             *
 * This source code and the accompanying materials are made available under    *
 * the terms of the Apache License 2.0 which accompanies this distribution.    *
 ******************************************************************************/

#include "cudaq/Frontend/nvqpp/AttributeNames.h"
#include "cudaq/Optimizer/Dialect/CC/CCTypes.h"
#include "cudaq/Optimizer/Dialect/Quake/QuakeOps.h"
#include "cudaq/Target/Emitter.h"
#include "cudaq/Target/Python/CUDAQPythonEmitter.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/TypeSwitch.h"

using namespace mlir;
using namespace cudaq;

//===----------------------------------------------------------------------===//
// Helper functions
//===----------------------------------------------------------------------===//

/// Translates operation names into CUDA Quantum Python gate names
static LogicalResult translateOperatorName(quake::OperatorInterface optor,
                                           std::string &name) {
  name = optor->getName().stripDialect().str();

  if (optor.getControls().size() == 1) {
    name = StringSwitch<std::string>(name)
               .Case("h", "ch")
               .Case("x", "cx")
               .Case("y", "cy")
               .Case("z", "cz")
               .Case("r1", "cu1")
               .Case("rx", "crx")
               .Case("ry", "cry")
               .Case("rz", "crz")
               .Default("");
  }
  if (name.empty())
    return failure();
  return success();
}

static LogicalResult printParameters(Emitter &emitter, ValueRange parameters) {
  if (parameters.empty())
    return success();
  auto isFailure = false;
  llvm::interleaveComma(parameters, emitter.os, [&](Value value) {
    auto parameter = getParameterValueAsDouble(value);
    if (!parameter.has_value()) {
      isFailure = true;
      return;
    }
    emitter.os << *parameter;
  });
  emitter.os << ',';
  return failure(isFailure);
}

// static StringRef printClassicalAllocation(Emitter &emitter, Value
// bitOrVector,
//                                           size_t size) {
//   auto name = emitter.createName();
//   emitter.os << llvm::formatv("creg {0}[{1}];\n", name, size);
//   if (size == 1)
//     name.append("[0]");
//   return emitter.getOrAssignName(bitOrVector, name);
// }

//===----------------------------------------------------------------------===//
// Emitters functions
//===----------------------------------------------------------------------===//

static LogicalResult emitOperation(Emitter &emitter, Operation &op);

static LogicalResult emitEntryPoint(Emitter &emitter, func::FuncOp kernel) {
  Emitter::Scope scope(emitter, /*isEntryPoint=*/true);
  emitter.os << "kernel = cudaq.make_kernel()\n";
  for (Operation &op : kernel.getOps())
    if (failed(emitOperation(emitter, op)))
      return failure();

  emitter.os << "\nprint(kernel)\n";
  return success();
}

static LogicalResult emitOperation(Emitter &emitter, ModuleOp moduleOp) {
  emitter.os << "# Code generated by NVIDIA's nvq++ compiler\n";
  emitter.os << "import cudaq\n\n";
  // For now assume Quake code with a single function
  Operation &op = *moduleOp.begin();
  if (failed(emitEntryPoint(emitter, dyn_cast<func::FuncOp>(op))))
    return failure();
  return success();
}

static LogicalResult emitOperation(Emitter &emitter, quake::AllocaOp allocaOp) {
  Value refOrVeq = allocaOp.getRefOrVec();
  auto name = emitter.createName();
  auto size = 1;
  if (auto veq = dyn_cast<quake::VeqType>(refOrVeq.getType())) {
    if (!veq.hasSpecifiedSize())
      return allocaOp.emitError("allocates unbounded veq");
    size = veq.getSize();
  }
  emitter.os << llvm::formatv("{0} = kernel.qalloc({1})\n", name, size);
  if (isa<quake::RefType>(refOrVeq.getType()))
    name.append("[0]");
  emitter.getOrAssignName(refOrVeq, name);
  return success();
}

static LogicalResult emitOperation(Emitter &emitter, quake::ExtractRefOp op) {
  std::optional<int64_t> index = std::nullopt;
  if (op.hasConstantIndex())
    index = op.getConstantIndex();
  else
    index = getIndexValueAsInt(op.getIndex());

  auto veqName = emitter.getOrAssignName(op.getVeq());
  auto qrefName = llvm::formatv("{0}[{1}]", veqName, *index);
  emitter.getOrAssignName(op.getRef(), qrefName);
  return success();
}

static LogicalResult emitOperation(Emitter &emitter,
                                   quake::OperatorInterface optor) {
  // TODO: Handle adjoint for T and S
  std::string name;
  if (failed(translateOperatorName(optor, name)))
    return optor.emitError(
        "cannot convert operation to CUDA Quantum Python API");

  if (optor.isAdj()) {
    name = name + "dg";
  }

  emitter.os << llvm::formatv("kernel.{0}(", name);

  if (failed(printParameters(emitter, optor.getParameters())))
    return optor.emitError("failed to emit parameters");

  if (!optor.getControls().empty()) {
    llvm::interleaveComma(optor.getControls(), emitter.os, [&](auto control) {
      emitter.os << emitter.getOrAssignName(control);
    });
    emitter.os << ',';
  }
  llvm::interleaveComma(optor.getTargets(), emitter.os, [&](auto target) {
    emitter.os << emitter.getOrAssignName(target);
  });
  emitter.os << ")\n";
  return success();
}

static LogicalResult emitOperation(Emitter &emitter, quake::MzOp op) {
  // if (op.getTargets().size() > 1)
  //   return op.emitError(
  //       "cannot translate measurements with more than one target");
  // auto qrefOrVeq = op.getTargets()[0];
  // auto size = 1;
  // if (auto veq = dyn_cast<quake::VeqType>(qrefOrVeq.getType())) {
  //   if (!veq.hasSpecifiedSize())
  //     return op.emitError("cannot emmit measure on an unbounded veq");
  //   size = veq.getSize();
  // }
  // auto bitsName = printClassicalAllocation(emitter, op.getBits(), size);
  // emitter.os << "measure " << emitter.getOrAssignName(qrefOrVeq) << " -> "
  //            << bitsName << ";\n";
  return success();
}

static LogicalResult emitOperation(Emitter &emitter, quake::ResetOp op) {
  emitter.os << "kernel.reset(" << emitter.getOrAssignName(op.getTargets())
             << ")";
  return success();
}

static LogicalResult emitOperation(Emitter &emitter, Operation &op) {
  using namespace quake;
  return llvm::TypeSwitch<Operation *, LogicalResult>(&op)
      // MLIR
      .Case<ModuleOp>([&](auto op) { return emitOperation(emitter, op); })
      // Quake
      .Case<AllocaOp>([&](auto op) { return emitOperation(emitter, op); })
      .Case<ExtractRefOp>([&](auto op) { return emitOperation(emitter, op); })
      .Case<OperatorInterface>(
          [&](auto optor) { return emitOperation(emitter, optor); })
      .Case<MzOp>([&](auto op) { return emitOperation(emitter, op); })
      .Case<ResetOp>([&](auto op) { return emitOperation(emitter, op); })
      // Ignore
      .Case<DeallocOp>([&](auto op) { return success(); })
      .Case<func::ReturnOp>([&](auto op) { return success(); })
      .Case<arith::ConstantOp>([&](auto op) { return success(); })
      .Default([&](Operation *) -> LogicalResult {
        if (op.getName().getDialectNamespace().equals("llvm"))
          return success();
        return op.emitOpError(
            "unable to translate op to CUDA Quantum Python API.");
      });
}

LogicalResult cudaq::translateToCUDAQPython(Operation *op, raw_ostream &os) {
  Emitter emitter(os);
  return emitOperation(emitter, *op);
}
