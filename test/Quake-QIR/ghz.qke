// ========================================================================== //
// Copyright (c) 2022 - 2024 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt %s --canonicalize --add-dealloc | cudaq-translate --convert-to=qir | FileCheck %s

module {
  func.func @ghz(%arg0 : i32) {
    %c0 = arith.constant 0 : i32
    %one = arith.constant 1 : i32
    %q = quake.alloca !quake.veq<?>[%arg0 : i32]
    %q0 = quake.extract_ref %q [%c0] : (!quake.veq<?>,i32) -> !quake.ref
    quake.h %q0 : (!quake.ref) -> ()
    %size_m_1 = arith.subi %arg0, %one : i32
    %upper = arith.index_cast %size_m_1 : i32 to index
    affine.for %i = 0 to %upper {
      %i_int = arith.index_cast %i : index to i32
      %ip1 = arith.addi %i_int, %one : i32
      %qi = quake.extract_ref %q [%i] : (!quake.veq<?>,index) -> !quake.ref
      %qi1 = quake.extract_ref %q [%ip1] : (!quake.veq<?>,i32) -> !quake.ref
      quake.x [%qi] %qi1 : (!quake.ref,!quake.ref) -> ()
    }
    return
  }
}
// CHECK-LABEL: define void @ghz(i32 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_1:.*]] = zext i32 %[[VAL_0]] to i64
// CHECK:         %[[VAL_2:.*]] = tail call target("qir#Array") @__quantum__rt__qubit_allocate_array(i64 %[[VAL_1]])
// CHECK:         %[[VAL_3:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_2]], i64 0)
// CHECK:         tail call void @__quantum__qis__h(target("qir#Qubit") %[[VAL_3]])
// CHECK:         %[[VAL_4:.*]] = add i32 %[[VAL_0]], -1
// CHECK:         %[[VAL_5:.*]] = sext i32 %[[VAL_4]] to i64
// CHECK:         %[[VAL_6:.*]] = icmp sgt i32 %[[VAL_4]], 0
// CHECK:         br i1 %[[VAL_6]], label %[[VAL_7:.*]], label %[[VAL_8:.*]]
// CHECK:       [[VAL_7]]:
// CHECK-SAME:  preds = %[[VAL_9:.*]], %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = phi i64 [ %[[VAL_11:.*]], %[[VAL_7]] ], [ 0, %[[VAL_9]] ]
// CHECK:         %[[VAL_11]] = add nuw nsw i64 %[[VAL_10]], 1
// CHECK:         %[[VAL_12:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_2]], i64 %[[VAL_10]])
// CHECK:         %[[VAL_13:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_2]], i64 %[[VAL_11]])
// CHECK:         tail call void (i64, ptr, ...) @invokeWithControlQubits(i64 1, ptr nonnull @__quantum__qis__x__ctl, target("qir#Qubit") %[[VAL_12]], target("qir#Qubit") %[[VAL_13]])
// CHECK:         %[[VAL_14:.*]] = icmp eq i64 %[[VAL_11]], %[[VAL_5]]
// CHECK:         br i1 %[[VAL_14]], label %[[VAL_8]], label %[[VAL_7]]
// CHECK:       [[VAL_8]]:
// CHECK-SAME:  preds = %[[VAL_7]], %[[VAL_9]]
// CHECK:         tail call void @__quantum__rt__qubit_release_array(target("qir#Array") %[[VAL_2]])
// CHECK:         ret void
// CHECK:       }

