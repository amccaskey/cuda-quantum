// ========================================================================== //
// Copyright (c) 2022 - 2024 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --add-dealloc --kernel-execution --canonicalize %s | \
// RUN: cudaq-translate --convert-to=qir | FileCheck %s

// NB: the mangled name map is required for the kernel-execution pass.
module attributes{ quake.mangled_name_map = {
  __nvqpp__mlirgen__test_0 = "test_0",
  __nvqpp__mlirgen__test_1 = "test_1",
  __nvqpp__mlirgen__test_2 = "test_2",
  __nvqpp__mlirgen__test_3 = "test_3",
  __nvqpp__mlirgen__test_4 = "test_4",
  __nvqpp__mlirgen__test_5 = "test_5" }} {

func.func private @__nvqpp_vectorCopyCtor(%arg0: !cc.ptr<i8> , %arg1: i64 , %arg2: i64 ) -> !cc.ptr<i8>

func.func @__nvqpp__mlirgen__test_0(%arg0: i32) -> !cc.stdvec<i1> {
  %c1_i64 = arith.constant 1 : i64
  %c1 = arith.constant 1 : i64
  %c0 = arith.constant 0 : i64
  %0 = cc.alloca i32
  cc.store %arg0, %0 : !cc.ptr<i32>
  %1 = cc.load %0 : !cc.ptr<i32>
  %2 = arith.extsi %1 : i32 to i64
  %3 = quake.alloca !quake.veq<?>[%2 : i64]
  %4 = quake.veq_size %3 : (!quake.veq<?>) -> i64
  %6 = cc.loop while ((%arg1 = %c0) -> (i64)) {
    %12 = arith.cmpi slt, %arg1, %4 : i64
    cc.condition %12(%arg1 : i64)
  } do {
  ^bb0(%arg1: i64):
    %12 = quake.extract_ref %3[%arg1] : (!quake.veq<?>, i64) -> !quake.ref
    quake.h %12 : (!quake.ref) -> ()
    cc.continue %arg1 : i64
  } step {
  ^bb0(%arg1: i64):
    %12 = arith.addi %arg1, %c1 : i64
    cc.continue %12 : i64
  } {invariant}
  %measOut = quake.mz %3 : (!quake.veq<?>) -> !cc.stdvec<!quake.measure>
  %7 = quake.discriminate %measOut : (!cc.stdvec<!quake.measure>) -> !cc.stdvec<i1>
  %8 = cc.stdvec_data %7 : (!cc.stdvec<i1>) -> !cc.ptr<i8>
  %9 = cc.stdvec_size %7 : (!cc.stdvec<i1>) -> i64
  %10 = call @__nvqpp_vectorCopyCtor(%8, %9, %c1_i64) : (!cc.ptr<i8>, i64, i64) -> !cc.ptr<i8>
  %11 = cc.stdvec_init %10, %9 : (!cc.ptr<i8>, i64) -> !cc.stdvec<i1>
  return %11 : !cc.stdvec<i1>
}

func.func @test_0(%1: !cc.ptr<!cc.struct<{!cc.ptr<i8>, !cc.ptr<i8>, !cc.ptr<i8>}>> {llvm.sret = !cc.struct<{!cc.ptr<i8>, !cc.ptr<i8>, !cc.ptr<i8>}>}, %this: !cc.ptr<i8>, %2: i32) {
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__test_0(ptr nocapture writeonly sret({ ptr, i64 }) 
// CHECK-SAME:    %[[VAL_0:.*]], i32 %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = sext i32 %[[VAL_1]] to i64
// CHECK:         %[[VAL_3:.*]] = tail call target("qir#Array") @__quantum__rt__qubit_allocate_array(i64 %[[VAL_2]])
// CHECK:         %[[VAL_4:.*]] = tail call i64 @__quantum__rt__array_get_size_1d(target("qir#Array") %[[VAL_3]])
// CHECK:         %[[VAL_5:.*]] = icmp sgt i64 %[[VAL_4]], 0
// CHECK:         br i1 %[[VAL_5]], label %[[VAL_6:.*]], label %[[VAL_7:.*]]
// CHECK:       [[VAL_7]]:                               ; preds = %[[VAL_8:.*]]
// CHECK:         %[[VAL_9:.*]] = alloca i1, i64 %[[VAL_4]], align 1
// CHECK:         br label %[[VAL_10:.*]]
// CHECK:       [[VAL_6]]:                                           ; preds = %[[VAL_8]], %[[VAL_6]]
// CHECK:         %[[VAL_11:.*]] = phi i64 [ %[[VAL_12:.*]], %[[VAL_6]] ], [ 0, %[[VAL_8]] ]
// CHECK:         %[[VAL_13:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_3]], i64 %[[VAL_11]])
// CHECK:         tail call void @__quantum__qis__h(target("qir#Qubit") %[[VAL_13]])
// CHECK:         %[[VAL_12]] = add nuw nsw i64 %[[VAL_11]], 1
// CHECK:         %[[VAL_14:.*]] = icmp eq i64 %[[VAL_12]], %[[VAL_4]]
// CHECK:         br i1 %[[VAL_14]], label %[[VAL_15:.*]], label %[[VAL_6]]
// CHECK:       [[VAL_15]]:                                      ; preds = %[[VAL_6]]
// CHECK:         %[[VAL_16:.*]] = alloca i1, i64 %[[VAL_4]], align 1
// CHECK:         br i1 %[[VAL_5]], label %[[VAL_17:.*]], label %[[VAL_10]]
// CHECK:       [[VAL_17]]:                                          ; preds = %[[VAL_15]], %[[VAL_17]]
// CHECK:         %[[VAL_18:.*]] = phi i64 [ %[[VAL_19:.*]], %[[VAL_17]] ], [ 0, %[[VAL_15]] ]
// CHECK:         %[[VAL_20:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_3]], i64 %[[VAL_18]])
// CHECK:         %[[VAL_21:.*]] = tail call target("qir#Result") @__quantum__qis__mz(target("qir#Qubit") %[[VAL_20]])
// CHECK:         %[[VAL_22:.*]] = tail call ptr @llvm.qir.getResultPtr(target("qir#Result") %[[VAL_21]])
// CHECK:         %[[VAL_23:.*]] = load i1, ptr %[[VAL_22]], align 1
// CHECK:         %[[VAL_24:.*]] = getelementptr inbounds i1, ptr %[[VAL_16]], i64 %[[VAL_18]]
// CHECK:         store i1 %[[VAL_23]], ptr %[[VAL_24]], align 1
// CHECK:         %[[VAL_19]] = add nuw nsw i64 %[[VAL_18]], 1
// CHECK:         %[[VAL_25:.*]] = icmp eq i64 %[[VAL_19]], %[[VAL_4]]
// CHECK:         br i1 %[[VAL_25]], label %[[VAL_10]], label %[[VAL_17]]
// CHECK:       [[VAL_10]]:                                     ; preds = %[[VAL_17]], %[[VAL_7]], %[[VAL_15]]
// CHECK:         %[[VAL_26:.*]] = phi ptr [ %[[VAL_9]], %[[VAL_7]] ], [ %[[VAL_16]], %[[VAL_15]] ], [ %[[VAL_16]], %[[VAL_17]] ]
// CHECK:         %[[VAL_27:.*]] = call ptr @__nvqpp_vectorCopyCtor(ptr nonnull %[[VAL_26]], i64 %[[VAL_4]], i64 1)
// CHECK:         call void @__quantum__rt__qubit_release_array(target("qir#Array") %[[VAL_3]])
// CHECK:         store ptr %[[VAL_27]], ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_28:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store i64 %[[VAL_4]], ptr %[[VAL_28]], align 8
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define void @test_0(ptr sret({ ptr, ptr, ptr }) 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture readnone %[[VAL_1:.*]], i32 %[[VAL_2:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_3:.*]] = alloca [24 x i8], align 1
// CHECK:         store i32 %[[VAL_2]], ptr %[[VAL_3]], align 8
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_3]], i64 8
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, ptr %[[VAL_3]], i64 16
// CHECK:         call void @altLaunchKernel(ptr nonnull @test_0.kernelName, ptr nonnull @test_0.thunk, ptr nonnull %[[VAL_3]], i64 24, i64 8)
// CHECK:         %[[VAL_6:.*]] = load ptr, ptr %[[VAL_4]], align 8
// CHECK:         %[[VAL_7:.*]] = load i64, ptr %[[VAL_5]], align 4
// CHECK:         call void @__nvqpp_initializer_list_to_vector_bool(ptr %[[VAL_0]], ptr %[[VAL_6]], i64 %[[VAL_7]])
// CHECK:         ret void
// CHECK:       }

func.func @__nvqpp__mlirgen__test_1() -> !cc.struct<{i1, i1}> {
  %qubits = quake.alloca !quake.veq<2>
  %q0 = quake.extract_ref %qubits[0] : (!quake.veq<2>) -> !quake.ref
  %q1 = quake.extract_ref %qubits[1] : (!quake.veq<2>) -> !quake.ref
  quake.h %q0 : (!quake.ref) -> ()
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  %m0 = quake.mz %q0 : (!quake.ref) -> !quake.measure
  %m1 = quake.mz %q1 : (!quake.ref) -> !quake.measure
  %rv = cc.undef !cc.struct<{i1, i1}>
  %d1 = quake.discriminate %m0 : (!quake.measure) -> i1
  %rv1 = cc.insert_value %d1, %rv[0] : (!cc.struct<{i1, i1}>, i1) -> !cc.struct<{i1, i1}>
  %d2 = quake.discriminate %m1 : (!quake.measure) -> i1
  %rv2 = cc.insert_value %d2, %rv1[1] : (!cc.struct<{i1, i1}>, i1) -> !cc.struct<{i1, i1}>
  return %rv2 : !cc.struct<{i1, i1}>
}

func.func @test_1(%1: !cc.ptr<!cc.struct<{i1, i1}>> {llvm.sret = !cc.struct<{i1, i1}>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__test_1(ptr nocapture writeonly sret({ i1, i1 }) 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_1:.*]] = tail call target("qir#Array") @__quantum__rt__qubit_allocate_array(i64 2)
// CHECK:         %[[VAL_2:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_1]], i64 0)
// CHECK:         %[[VAL_3:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_1]], i64 1)
// CHECK:         tail call void @__quantum__qis__h(target("qir#Qubit") %[[VAL_2]])
// CHECK:         tail call void (i64, ptr, ...) @invokeWithControlQubits(i64 1, ptr nonnull @__quantum__qis__x__ctl, target("qir#Qubit") %[[VAL_2]], target("qir#Qubit") %[[VAL_3]])
// CHECK:         %[[VAL_4:.*]] = tail call target("qir#Result") @__quantum__qis__mz(target("qir#Qubit") %[[VAL_2]])
// CHECK:         %[[VAL_5:.*]] = tail call target("qir#Result") @__quantum__qis__mz(target("qir#Qubit") %[[VAL_3]])
// CHECK:         %[[VAL_6:.*]] = tail call ptr @llvm.qir.getResultPtr(target("qir#Result") %[[VAL_4]])
// CHECK:         %[[VAL_7:.*]] = load i1, ptr %[[VAL_6]], align 1
// CHECK:         %[[VAL_8:.*]] = tail call ptr @llvm.qir.getResultPtr(target("qir#Result") %[[VAL_5]])
// CHECK:         %[[VAL_9:.*]] = load i1, ptr %[[VAL_8]], align 1
// CHECK:         store i1 %[[VAL_7]], ptr %[[VAL_0]], align 1
// CHECK:         %[[VAL_10:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 1
// CHECK:         store i1 %[[VAL_9]], ptr %[[VAL_10]], align 1
// CHECK:         tail call void @__quantum__rt__qubit_release_array(target("qir#Array") %[[VAL_1]])
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define void @test_1(ptr nocapture writeonly sret({ i1, i1 }) 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture readnone %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = alloca [2 x i8], align 1
// CHECK:         call void @altLaunchKernel(ptr nonnull @test_1.kernelName, ptr nonnull @test_1.thunk, ptr nonnull %[[VAL_2]], i64 2, i64 0)
// CHECK:         %[[VAL_3:.*]] = load i1, ptr %[[VAL_2]], align 1
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 1
// CHECK:         %[[VAL_5:.*]] = load i1, ptr %[[VAL_4]], align 1
// CHECK:         store i1 %[[VAL_3]], ptr %[[VAL_0]], align 1
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 1
// CHECK:         store i1 %[[VAL_5]], ptr %[[VAL_6]], align 1
// CHECK:         ret void
// CHECK:       }


func.func @__nvqpp__mlirgen__test_2() -> !cc.struct<{i16, f32, f64, i64}> {
  %rv = cc.undef !cc.struct<{i16, f32, f64, i64}>
  %c1 = arith.constant 8 : i16
  %rv1 = cc.insert_value %c1, %rv[0] : (!cc.struct<{i16, f32, f64, i64}>, i16) -> !cc.struct<{i16, f32, f64, i64}>
  %c2 = arith.constant 5.4 : f32
  %rv2 = cc.insert_value %c2, %rv1[1] : (!cc.struct<{i16, f32, f64, i64}>, f32) -> !cc.struct<{i16, f32, f64, i64}>
  %c3 = arith.constant 37.83 : f64
  %rv3 = cc.insert_value %c3, %rv2[2] : (!cc.struct<{i16, f32, f64, i64}>, f64) -> !cc.struct<{i16, f32, f64, i64}>
  %c4 = arith.constant 1479 : i64
  %rv4 = cc.insert_value %c4, %rv3[3] : (!cc.struct<{i16, f32, f64, i64}>, i64) -> !cc.struct<{i16, f32, f64, i64}>
  return %rv4 : !cc.struct<{i16, f32, f64, i64}>
}

func.func @test_2(%1: !cc.ptr<!cc.struct<{i16, f32, f64, i64}>> {llvm.sret = !cc.struct<{i16, f32, f64, i64}>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__test_2(ptr nocapture writeonly sret({ i16, float, double, i64 }) 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr #
// CHECK:         store { i16, float, double, i64 } { i16 8, float 0x40159999A0000000, double 3.783000e+01, i64 1479 }, ptr %[[VAL_0]], align 8
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define void @test_2(ptr nocapture writeonly sret({ i16, float, double, i64 }) 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture readnone %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = alloca [24 x i8], align 1
// CHECK:         call void @altLaunchKernel(ptr nonnull @test_2.kernelName, ptr nonnull @test_2.thunk, ptr nonnull %[[VAL_2]], i64 24, i64 0)
// CHECK:         %[[VAL_3:.*]] = load i16, ptr %[[VAL_2]], align 8
// CHECK:         %[[VAL_4:.*]] = insertvalue { i16, float, double, i64 } poison, i16 %[[VAL_3]], 0
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 4
// CHECK:         %[[VAL_6:.*]] = load float, ptr %[[VAL_5]], align 4
// CHECK:         %[[VAL_7:.*]] = insertvalue { i16, float, double, i64 } %[[VAL_4]], float %[[VAL_6]], 1
// CHECK:         %[[VAL_8:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 8
// CHECK:         %[[VAL_9:.*]] = load double, ptr %[[VAL_8]], align 8
// CHECK:         %[[VAL_10:.*]] = insertvalue { i16, float, double, i64 } %[[VAL_7]], double %[[VAL_9]], 2
// CHECK:         %[[VAL_11:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 16
// CHECK:         %[[VAL_12:.*]] = load i64, ptr %[[VAL_11]], align 8
// CHECK:         %[[VAL_13:.*]] = insertvalue { i16, float, double, i64 } %[[VAL_10]], i64 %[[VAL_12]], 3
// CHECK:         store { i16, float, double, i64 } %[[VAL_13]], ptr %[[VAL_0]], align 8
// CHECK:         ret void
// CHECK:       }

func.func @__nvqpp__mlirgen__test_3() -> !cc.array<i64 x 5> {
  %rv = cc.undef !cc.array<i64 x 5>
  %c1 = arith.constant 5 : i64
  %rv1 = cc.insert_value %c1, %rv[0] : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c2 = arith.constant 74 : i64
  %rv2 = cc.insert_value %c2, %rv1[1] : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c3 = arith.constant 299 : i64
  %rv3 = cc.insert_value %c3, %rv2[2] : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c4 = arith.constant 1659 : i64
  %rv4 = cc.insert_value %c4, %rv3[3] : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c5 = arith.constant 61234 : i64
  %rv5 = cc.insert_value %c5, %rv4[4] : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  return %rv5 : !cc.array<i64 x 5>
}

func.func @test_3(%1: !cc.ptr<!cc.array<i64 x 5>> {llvm.sret = !cc.array<i64 x 5>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__test_3(ptr nocapture writeonly sret([5 x i64]) 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr #
// CHECK:         store i64 5, ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_1:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store i64 74, ptr %[[VAL_1]], align 8
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 16
// CHECK:         store i64 299, ptr %[[VAL_2]], align 8
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 24
// CHECK:         store i64 1659, ptr %[[VAL_3]], align 8
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 32
// CHECK:         store i64 61234, ptr %[[VAL_4]], align 8
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define void @test_3(ptr nocapture writeonly sret([5 x i64]) 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture readnone %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = alloca [40 x i8], align 8
// CHECK:         call void @altLaunchKernel(ptr nonnull @test_3.kernelName, ptr nonnull @test_3.thunk, ptr nonnull %[[VAL_2]], i64 40, i64 0)
// CHECK:         %[[VAL_3:.*]] = load i64, ptr %[[VAL_2]], align 8
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 8
// CHECK:         %[[VAL_5:.*]] = load i64, ptr %[[VAL_4]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 16
// CHECK:         %[[VAL_7:.*]] = load i64, ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_8:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 24
// CHECK:         %[[VAL_9:.*]] = load i64, ptr %[[VAL_8]], align 8
// CHECK:         %[[VAL_10:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 32
// CHECK:         %[[VAL_11:.*]] = load i64, ptr %[[VAL_10]], align 8
// CHECK:         store i64 %[[VAL_3]], ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_12:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store i64 %[[VAL_5]], ptr %[[VAL_12]], align 8
// CHECK:         %[[VAL_13:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 16
// CHECK:         store i64 %[[VAL_7]], ptr %[[VAL_13]], align 8
// CHECK:         %[[VAL_14:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 24
// CHECK:         store i64 %[[VAL_9]], ptr %[[VAL_14]], align 8
// CHECK:         %[[VAL_15:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 32
// CHECK:         store i64 %[[VAL_11]], ptr %[[VAL_15]], align 8
// CHECK:         ret void
// CHECK:       }

func.func @__nvqpp__mlirgen__test_4() -> (i64, f64) {
  %c1 = arith.constant 537892 : i64
  %c2 = arith.constant 94.2134 : f64
  return %c1, %c2 : i64, f64
}

func.func @test_4(%1: !cc.ptr<!cc.struct<{i64, f64}>> {llvm.sret = !cc.struct<{i64, f64}>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__test_4(ptr nocapture writeonly sret({ i64, double }) 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr #
// CHECK:         store i64 537892, ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_1:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double 0x40578DA858793DD9, ptr %[[VAL_1]], align 8
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define void @test_4(ptr nocapture writeonly sret({ i64, double }) 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture readnone %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = alloca [16 x i8], align 8
// CHECK:         call void @altLaunchKernel(ptr nonnull @test_4.kernelName, ptr nonnull @test_4.thunk, ptr nonnull %[[VAL_2]], i64 16, i64 0)
// CHECK:         %[[VAL_3:.*]] = load i64, ptr %[[VAL_2]], align 8
// CHECK:         store i64 %[[VAL_3]], ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_2]], i64 8
// CHECK:         %[[VAL_5:.*]] = load double, ptr %[[VAL_4]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double %[[VAL_5]], ptr %[[VAL_6]], align 8
// CHECK:         ret void
// CHECK:       }

func.func @__nvqpp__mlirgen__test_5() -> (i64, f64) attributes {no_this} {
  %c1 = arith.constant 537892 : i64
  %c2 = arith.constant 94.2134 : f64
  return %c1, %c2 : i64, f64
}

func.func @test_5(%0: !cc.ptr<!cc.struct<{i64, f64}>> {llvm.sret = !cc.struct<{i64, f64}>}) {
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__test_5(ptr nocapture writeonly sret({ i64, double }) 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr #
// CHECK:         store i64 537892, ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_1:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double 0x40578DA858793DD9, ptr %[[VAL_1]], align 8
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define void @test_5(ptr nocapture writeonly sret({ i64, double }) 
// CHECK-SAME:    %[[VAL_0:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_1:.*]] = alloca [16 x i8], align 8
// CHECK:         call void @altLaunchKernel(ptr nonnull @test_5.kernelName, ptr nonnull @test_5.thunk, ptr nonnull %[[VAL_1]], i64 16, i64 0)
// CHECK:         %[[VAL_2:.*]] = load i64, ptr %[[VAL_1]], align 8
// CHECK:         store i64 %[[VAL_2]], ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, ptr %[[VAL_1]], i64 8
// CHECK:         %[[VAL_4:.*]] = load double, ptr %[[VAL_3]], align 8
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double %[[VAL_4]], ptr %[[VAL_5]], align 8
// CHECK:         ret void
// CHECK:       }

}

// CHECK-LABEL: define { ptr, i64 } @test_0.thunk(ptr nocapture 
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) {
// CHECK:         %[[VAL_2:.*]] = load i32, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         %[[VAL_4:.*]] = sext i32 %[[VAL_2]] to i64
// CHECK:         %[[VAL_5:.*]] = tail call target("qir#Array") @__quantum__rt__qubit_allocate_array(i64 %[[VAL_4]])
// CHECK:         %[[VAL_6:.*]] = tail call i64 @__quantum__rt__array_get_size_1d(target("qir#Array") %[[VAL_5]])
// CHECK:         %[[VAL_7:.*]] = icmp sgt i64 %[[VAL_6]], 0
// CHECK:         br i1 %[[VAL_7]], label %[[VAL_8:.*]], label %[[VAL_9:.*]]
// CHECK:       [[VAL_9]]:                               ; preds = %[[VAL_10:.*]]
// CHECK:         %[[VAL_11:.*]] = alloca i1, i64 %[[VAL_6]], align 1
// CHECK:         br label %[[VAL_12:.*]]
// CHECK:       [[VAL_8]]:                                           ; preds = %[[VAL_10]], %[[VAL_8]]
// CHECK:         %[[VAL_13:.*]] = phi i64 [ %[[VAL_14:.*]], %[[VAL_8]] ], [ 0, %[[VAL_10]] ]
// CHECK:         %[[VAL_15:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_5]], i64 %[[VAL_13]])
// CHECK:         tail call void @__quantum__qis__h(target("qir#Qubit") %[[VAL_15]])
// CHECK:         %[[VAL_14]] = add nuw nsw i64 %[[VAL_13]], 1
// CHECK:         %[[VAL_16:.*]] = icmp eq i64 %[[VAL_14]], %[[VAL_6]]
// CHECK:         br i1 %[[VAL_16]], label %[[VAL_17:.*]], label %[[VAL_8]]
// CHECK:       [[VAL_17]]:                                      ; preds = %[[VAL_8]]
// CHECK:         %[[VAL_18:.*]] = alloca i1, i64 %[[VAL_6]], align 1
// CHECK:         br i1 %[[VAL_7]], label %[[VAL_19:.*]], label %[[VAL_12]]
// CHECK:       [[VAL_19]]:                                          ; preds = %[[VAL_17]], %[[VAL_19]]
// CHECK:         %[[VAL_20:.*]] = phi i64 [ %[[VAL_21:.*]], %[[VAL_19]] ], [ 0, %[[VAL_17]] ]
// CHECK:         %[[VAL_22:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_5]], i64 %[[VAL_20]])
// CHECK:         %[[VAL_23:.*]] = tail call target("qir#Result") @__quantum__qis__mz(target("qir#Qubit") %[[VAL_22]])
// CHECK:         %[[VAL_24:.*]] = tail call ptr @llvm.qir.getResultPtr(target("qir#Result") %[[VAL_23]])
// CHECK:         %[[VAL_25:.*]] = load i1, ptr %[[VAL_24]], align 1
// CHECK:         %[[VAL_26:.*]] = getelementptr inbounds i1, ptr %[[VAL_18]], i64 %[[VAL_20]]
// CHECK:         store i1 %[[VAL_25]], ptr %[[VAL_26]], align 1
// CHECK:         %[[VAL_21]] = add nuw nsw i64 %[[VAL_20]], 1
// CHECK:         %[[VAL_27:.*]] = icmp eq i64 %[[VAL_21]], %[[VAL_6]]
// CHECK:         br i1 %[[VAL_27]], label %[[VAL_12]], label %[[VAL_19]]
// CHECK:       [[VAL_12]]:                                     ; preds = %[[VAL_19]], %[[VAL_9]], %[[VAL_17]]
// CHECK:         %[[VAL_28:.*]] = phi ptr [ %[[VAL_11]], %[[VAL_9]] ], [ %[[VAL_18]], %[[VAL_17]] ], [ %[[VAL_18]], %[[VAL_19]] ]
// CHECK:         %[[VAL_29:.*]] = call ptr @__nvqpp_vectorCopyCtor(ptr nonnull %[[VAL_28]], i64 %[[VAL_6]], i64 1)
// CHECK:         call void @__quantum__rt__qubit_release_array(target("qir#Array") %[[VAL_5]])
// CHECK:         store ptr %[[VAL_29]], ptr %[[VAL_3]], align 8
// CHECK:         %[[VAL_30:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 16
// CHECK:         store i64 %[[VAL_6]], ptr %[[VAL_30]], align 4
// CHECK:         br i1 %[[VAL_1]], label %[[VAL_31:.*]], label %[[VAL_32:.*]]
// CHECK:       [[VAL_32]]:                                       ; preds = %[[VAL_12]], %[[VAL_31]]
// CHECK:         %[[VAL_33:.*]] = phi { ptr, i64 } [ %[[VAL_34:.*]], %[[VAL_31]] ], [ zeroinitializer, %[[VAL_12]] ]
// CHECK:         ret { ptr, i64 } %[[VAL_33]]
// CHECK:       [[VAL_31]]:                                               ; preds = %[[VAL_12]]
// CHECK:         %[[VAL_35:.*]] = add i64 %[[VAL_6]], 24
// CHECK:         %[[VAL_36:.*]] = call ptr @malloc(i64 %[[VAL_35]])
// CHECK:         call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(24) %[[VAL_36]], ptr noundef nonnull align 1 dereferenceable(24) %[[VAL_0]], i64 24, i1 false)
// CHECK:         %[[VAL_37:.*]] = getelementptr inbounds i8, ptr %[[VAL_36]], i64 24
// CHECK:         call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %[[VAL_37]], ptr align 1 %[[VAL_29]], i64 %[[VAL_6]], i1 false)
// CHECK:         %[[VAL_38:.*]] = insertvalue { ptr, i64 } undef, ptr %[[VAL_36]], 0
// CHECK:         %[[VAL_34]] = insertvalue { ptr, i64 } %[[VAL_38]], i64 %[[VAL_35]], 1
// CHECK:         br label %[[VAL_32]]
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_0.argsCreator(ptr nocapture readonly 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture writeonly %[[VAL_1:.*]]) #
// CHECK:         %[[VAL_2:.*]] = load ptr, ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_3:.*]] = load i32, ptr %[[VAL_2]], align 4
// CHECK:         %[[VAL_4:.*]] = insertvalue { i32, { ptr, i64 } } undef, i32 %[[VAL_3]], 0
// CHECK:         %[[VAL_5:.*]] = tail call dereferenceable_or_null(24) ptr @malloc(i64 24)
// CHECK:         store { i32, { ptr, i64 } } %[[VAL_4]], ptr %[[VAL_5]], align 8
// CHECK:         store ptr %[[VAL_5]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 24
// CHECK:       }

// CHECK-LABEL: define void @test_0.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_0.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_0.kernelName, ptr nonnull @test_0.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_1.thunk(ptr nocapture writeonly 
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) {
// CHECK:         %[[VAL_2:.*]] = tail call target("qir#Array") @__quantum__rt__qubit_allocate_array(i64 2)
// CHECK:         %[[VAL_3:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_2]], i64 0)
// CHECK:         %[[VAL_4:.*]] = tail call target("qir#Qubit") @__quantum__rt__array_get_qubit_element(target("qir#Array") %[[VAL_2]], i64 1)
// CHECK:         tail call void @__quantum__qis__h(target("qir#Qubit") %[[VAL_3]])
// CHECK:         tail call void (i64, ptr, ...) @invokeWithControlQubits(i64 1, ptr nonnull @__quantum__qis__x__ctl, target("qir#Qubit") %[[VAL_3]], target("qir#Qubit") %[[VAL_4]])
// CHECK:         %[[VAL_5:.*]] = tail call target("qir#Result") @__quantum__qis__mz(target("qir#Qubit") %[[VAL_3]])
// CHECK:         %[[VAL_6:.*]] = tail call target("qir#Result") @__quantum__qis__mz(target("qir#Qubit") %[[VAL_4]])
// CHECK:         %[[VAL_7:.*]] = tail call ptr @llvm.qir.getResultPtr(target("qir#Result") %[[VAL_5]])
// CHECK:         %[[VAL_8:.*]] = load i1, ptr %[[VAL_7]], align 1
// CHECK:         %[[VAL_9:.*]] = tail call ptr @llvm.qir.getResultPtr(target("qir#Result") %[[VAL_6]])
// CHECK:         %[[VAL_10:.*]] = load i1, ptr %[[VAL_9]], align 1
// CHECK:         store i1 %[[VAL_8]], ptr %[[VAL_0]], align 1
// CHECK:         %[[VAL_11:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 1
// CHECK:         store i1 %[[VAL_10]], ptr %[[VAL_11]], align 1
// CHECK:         tail call void @__quantum__rt__qubit_release_array(target("qir#Array") %[[VAL_2]])
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }
// CHECK:       ; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: write, inaccessiblemem: readwrite)

// CHECK-LABEL: define noundef i64 @test_1.argsCreator(ptr nocapture readnone 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture writeonly %[[VAL_1:.*]]) #
// CHECK:         %[[VAL_2:.*]] = tail call dereferenceable_or_null(2) ptr @malloc(i64 2)
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 2
// CHECK:       }

// CHECK-LABEL: define void @test_1.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_1.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_1.kernelName, ptr nonnull @test_1.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_2.thunk(ptr nocapture writeonly 
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) #
// CHECK:         store { i16, float, double, i64 } { i16 8, float 0x40159999A0000000, double 3.783000e+01, i64 1479 }, ptr %[[VAL_0]], align 8
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_2.argsCreator(ptr nocapture readnone 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture writeonly %[[VAL_1:.*]]) #
// CHECK:         %[[VAL_2:.*]] = tail call dereferenceable_or_null(24) ptr @malloc(i64 24)
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 24
// CHECK:       }

// CHECK-LABEL: define void @test_2.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_2.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_2.kernelName, ptr nonnull @test_2.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_3.thunk(ptr nocapture writeonly 
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) #
// CHECK:         store i64 5, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store i64 74, ptr %[[VAL_2]], align 4
// CHECK:         %[[VAL_3:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 16
// CHECK:         store i64 299, ptr %[[VAL_3]], align 4
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 24
// CHECK:         store i64 1659, ptr %[[VAL_4]], align 4
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 32
// CHECK:         store i64 61234, ptr %[[VAL_5]], align 4
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_3.argsCreator(ptr nocapture readnone 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture writeonly %[[VAL_1:.*]]) #
// CHECK:         %[[VAL_2:.*]] = tail call dereferenceable_or_null(40) ptr @malloc(i64 40)
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 40
// CHECK:       }

// CHECK-LABEL: define void @test_3.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_3.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_3.kernelName, ptr nonnull @test_3.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_4.thunk(ptr nocapture writeonly 
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) #
// CHECK:         store i64 537892, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double 0x40578DA858793DD9, ptr %[[VAL_2]], align 8
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_4.argsCreator(ptr nocapture readnone 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture writeonly %[[VAL_1:.*]]) #
// CHECK:         %[[VAL_2:.*]] = tail call dereferenceable_or_null(16) ptr @malloc(i64 16)
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 16
// CHECK:       }

// CHECK-LABEL: define void @test_4.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_4.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_4.kernelName, ptr nonnull @test_4.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_5.thunk(ptr nocapture writeonly 
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) #
// CHECK:         store i64 537892, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double 0x40578DA858793DD9, ptr %[[VAL_2]], align 8
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_5.argsCreator(ptr nocapture readnone 
// CHECK-SAME:    %[[VAL_0:.*]], ptr nocapture writeonly %[[VAL_1:.*]]) #
// CHECK:         %[[VAL_2:.*]] = tail call dereferenceable_or_null(16) ptr @malloc(i64 16)
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 16
// CHECK:       }

// CHECK-LABEL: define void @test_5.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_5.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_5.kernelName, ptr nonnull @test_5.argsCreator)
// CHECK:         ret void
// CHECK:       }

