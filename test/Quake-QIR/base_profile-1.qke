// ========================================================================== //
// Copyright (c) 2022 - 2024 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-translate --convert-to=qir-base %s | FileCheck %s

func.func @__nvqpp__mlirgen__ghz() {
  %c2_i32 = arith.constant 2 : i32
  %c1_i32 = arith.constant 1 : i32
  %c1 = arith.constant 1 : index
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %c3_i32 = arith.constant 3 : i32
  %0 = quake.alloca !quake.veq<3>
  %1 = quake.extract_ref %0[%c0_i32] : (!quake.veq<3>,i32) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  %2 = quake.extract_ref %0[%c0] : (!quake.veq<3>, index) -> !quake.ref
  %3 = quake.extract_ref %0[%c1_i32] : (!quake.veq<3>,i32) -> !quake.ref
  quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
  %4 = quake.extract_ref %0[%c1] : (!quake.veq<3>,index) -> !quake.ref
  %5 = quake.extract_ref %0[%c2_i32] : (!quake.veq<3>,i32) -> !quake.ref
  quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
  %6 = quake.mz %1 : (!quake.ref) -> !quake.measure
  %7 = quake.mz %3 : (!quake.ref) -> !quake.measure
  %8 = quake.mz %5 : (!quake.ref) -> !quake.measure
  return
}

// CHECK-LABEL: define void @__nvqpp__mlirgen__ghz()
// CHECK:         %[[VAL_0:.*]] = tail call target("qir#Qubit") @llvm.qir.i64ToQubit(i64 0)
// CHECK:         tail call void @__quantum__qis__h__body(target("qir#Qubit") %[[VAL_0]])
// CHECK:         %[[VAL_1:.*]] = tail call target("qir#Qubit") @llvm.qir.i64ToQubit(i64 1)
// CHECK:         tail call void @__quantum__qis__cnot__body(target("qir#Qubit") %[[VAL_0]], target("qir#Qubit") %[[VAL_1]])
// CHECK:         %[[VAL_2:.*]] = tail call target("qir#Qubit") @llvm.qir.i64ToQubit(i64 2)
// CHECK:         tail call void @__quantum__qis__cnot__body(target("qir#Qubit") %[[VAL_1]], target("qir#Qubit") %[[VAL_2]])
// CHECK:         %[[VAL_3:.*]] = tail call target("qir#Result") @llvm.qir.i64ToResult(i64 0)
// CHECK:         tail call void @__quantum__qis__mz__body(target("qir#Qubit") %[[VAL_0]], target("qir#Result") %[[VAL_3]])
// CHECK:         %[[VAL_4:.*]] = tail call target("qir#Result") @llvm.qir.i64ToResult(i64 1)
// CHECK:         tail call void @__quantum__qis__mz__body(target("qir#Qubit") %[[VAL_1]], target("qir#Result") %[[VAL_4]])
// CHECK:         %[[VAL_5:.*]] = tail call target("qir#Result") @llvm.qir.i64ToResult(i64 2)
// CHECK:         tail call void @__quantum__qis__mz__body(target("qir#Qubit") %[[VAL_2]], target("qir#Result") %[[VAL_5]])
// CHECK:         %[[VAL_6:.*]] = tail call target("qir#Result") @llvm.qir.i64ToResult(i64 0)
// CHECK:         tail call void @__quantum__rt__result_record_output(target("qir#Result") %[[VAL_6]], ptr nonnull @cstr.72303030303000)
// CHECK:         %[[VAL_7:.*]] = tail call target("qir#Result") @llvm.qir.i64ToResult(i64 1)
// CHECK:         tail call void @__quantum__rt__result_record_output(target("qir#Result") %[[VAL_7]], ptr nonnull @cstr.72303030303100)
// CHECK:         %[[VAL_8:.*]] = tail call target("qir#Result") @llvm.qir.i64ToResult(i64 2)
// CHECK:         tail call void @__quantum__rt__result_record_output(target("qir#Result") %[[VAL_8]], ptr nonnull @cstr.72303030303200)
// CHECK:         ret void
// CHECK:       }


// CHECK: attributes #0 = { "irreversible" }
// CHECK: attributes #1 = { "entry_point" "output_labeling_schema"="schema_id" "output_names"="{{.*}}" "qir_profiles"="base_profile" "requiredQubits"="3" "requiredResults"="3" }
